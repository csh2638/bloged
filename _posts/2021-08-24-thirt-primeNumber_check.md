---
layout: post
title: "[알고리즘] 소수 판별하기 "
subtitle: Prime number...
categories: 알고리즘
tags: [python, algolithm, prime number]
---
##  소수(Prime Number)
소수는 2보다 큰 자연수 중 1과 자기자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수다.<br>ex)2, 3, 5, 7, 11....<br>
소수인지 아닌지 판별하기 위해 아래와 같은 소수 판별 함수를 생각해 볼 수 있다.
~~~python
# 소수 판별 함수
def is_prime_number(x):   # 매개변수 x가 소수인지 판별
    for i in range(2, x): # 2부터 x-1 까지의 수를 비교
        if x % i == 0:    # 나머지가 0이면 1과 자기자신 외에 나누어 떨어지는 수가 존재하기 때문에 소수가 아님
            return False: 
    return True           # 나머지가 0인게 없으면 소수
~~~
소수 판별 함수 알고리즘의 시간복잡도는 O(X)이다. 즉, 입력받는 x값이 크면 비효율적이게 된다.그렇다면 좀 더 효율적인 방법은 없을까?<br>
## 1. 자연수가 가지는 약수의 특징을 이용한다.
소수인지 아닌지 판별하는데 약수의 특징을 사용한다니..🤔 처음에는 무슨 소리인지 이해가 안됐다.<br>
예를들어 16의 약수들을 보자. 1, 2, 4, 8, 16이다. 4를 기준으로 양 옆의 약수를 곱하게 되면 16이 된다.<br>
풀어보자면
~~~python
1 x 16 = 16
2 x 8 = 16     
4 x 4 = 16    
8 x 2 = 16    
16 x 1 = 16
~~~
이런식으로 가운데의 약수인 4, 즉 16의 제곱근을 기준으로 각 등식이 대칭임을 확인할 수 있다.  
즉, 제곱근 보다 작은 수를 비교하면 대칭인 위치의 수까지 비교가 된다는 것 같다.  
그러므로 자연수X가 소수인지 확인하기 위해 2부터 X의 제곱근 까지만 확인하면 된다.
~~~python
# 소수 판별 함수(개선 버전)
import math

def is_prime_number(x):   # 매개변수 x가 소수인지 판별
    for i in range(2, int(math.sqrt(x)) + 1): # 2부터 x의 제곱근 까지 비교
        if x % i == 0:    # 나머지가 0이면 1과 자기자신 외에 나누어 떨어지는 수가 존재하기 때문에 소수가 아님
            return False: 
    return True           # 나머지가 0인게 없으면 소수
~~~

기존 소수 판별 함수의 시간복잡도인 O(X)에서 개선된 버전을 사용하면 비교하는 횟수가 줄어들어
때문에 O(X^2/1)로 줄어든다.<br>
## 2. 에라토스테네스의 체를 이용한다.
~~~python
1. 2부터 N까지의 자연수를 나열한다.
1. 남은 수 중에서 가장 작은 수 i를 찾는다.
2. 남은 수 중에서 i를 제외한 i의 배수를 모두 제거한다.
3. 더 이상 반복할 수 없을 때까지 2와 3을 반복한다.
~~~
이런식으로 수를 제거하면 2를 제외한 2의 배수, 3을 제외한 3의 배수..... 순으로 숫자가 제거되며 마지막에 남은 수들이 소수가 된다.
~~~python
import math

n = 1000 # 2부터 1000까지의 수를 판별
arr = [True for i in range(n + 1)] # 2 ~ 1000 까지의 수가 모두 True인 상태로 초기화

for i in range(2, int(math.sqrt(n)) + 1): # 2 ~ n의 제곱근까지 비교
    if arr[i] == True: # i가 남은 수인 경우(2부터 시작하며 n의 제곱근까지 증가)
        j = 2
        while i * j <= n: # i를 제외한 i의 배수를 모두 제거
            arr[i * j] = False
            j += 1
for i in range(2, n+1):
    if arr[i]:
        print(i, end = '')
~~~
에라토스테네스의 체 알고리즘의 시간복잡도는 O(NloglogN)으로 빠르지만 큰 메모리 공간이 요구된다.    
너무 큰 n이 주어졌을 때는 다른 방법을 사용하는 것이 좋다.







