---
layout: post
title: "[WINSOCK] 3. TCP 서버-클라이언트 구조"
categories: NETWORK
tags: [NETWORK, WINSOCK]
---

## TCP 서버-클라이언트 구조

TCP서버-클라이언트의 핵심 동작을 개념적으로 정리하면 다음과 같다.

1. 서버는 먼저 실행하여 클라이언트가 접속하기를 기다린다.(listen)
2. 클라이언트는 서버에 접속(connect)하여 데이터를 보낸다(send)
3. 서버는 클라이언트 접속을 수용하고(accept) 클라이언트가 보낸 데이터를 받아서(recv)처리 한다.
4. 서버는 처리한 데이터를 클라이언트에 보낸다.(send)
5. 클라이언트는 서버가 보낸 데이터를 받아서(recv) 처리한다.
6. 데이터를 주고 받는 과정을 모두 마치면 접속을 끊는다.(closesocket)

![active](https://user-images.githubusercontent.com/78485996/136697065-8f933cf2-a637-40f0-8de7-75ed96057278.PNG)


## TCP 서버-클라이언트 동작 원리

1. 서버는 소켓을 생성한 후 클라이언트가 접속하기를 기다린다. 이때 서버가 사용하는 소켓은 특정 포트번호(ex.9000)와 결합되어 있어서 이 포트 번호로 접속하는 클라이언트만 수용할 수 있다.

2. 클라이언트가 서버에 접속한다. 이때 TCP 프로토놀 수준에서 연결 설정을 위한 패킷 교환이 일어난다.

3. TCP 프로토콜 수준의 연결 절차가 끝나면 서버는 접속한 클라이언트와 통신할 수 있는 새로운 소켓을 생성한다. 이 소켓을 이용해 서버는 클라이언트와 데이터를 주고 받는다. 기존 소켓은 새로운 클라이언트 접속을 수용하는 용도로 계속 사용한다.

4. 일반적으로 서버측 소켓과 클라이언트 측 소켓이 일대일로 대응하지만 클라이언트 한 개가 소켓 두 개 이상을 사용해 서버에 접속할수도 있다.


## TCP 서버-클라이언트 분석

응용프로그램 관점에서 소켓은 운영체제의 TCP/IP 구현에서 제공하는 데이터 구조를 참조하기 위한 매개체이다. 응용 프로그램이 통신하려면 다음과 같은 요소들이 정의되어야 한다.

프로토콜 : 통신규약으로 소켓을 생성할때 결정한다.

지역(local) IP 주소와 지역 포트 번호 : 서버 또는 클라이언트 자신의 주소다.

원격(remote) IP 주소와 원격 포트 번호 : 서버 또는 클라이언트가 통신하는 상대의 주소다.

## TCP 서버 함수

일반적으로 TCP 서버는 다음과 같은 순서로 소켓 함수를 호출한다.

1. socket() 함수로 소켓을 생성함으로써 사용할 프로토콜을 결정한다.
2. bind() 함수로 지역 IP 주소와 지역 포트 번호를 결정한다.
3. listen() 함수로 TCP를 LISTENING 상태로 변경한다.
4. accept() 함수로 자신에게 접속한 클라이언트와 통신할 수 있는 새로운 소켓을 생성한다. 이때 원격 IP 주소와 원격 포트번호가 결정된다.
5. send(), recv()등의 데이터 전송 함수로 클라이언트와 통신을 수행한 후, closesocket()함수로 소켓을 닫는다.
6. 새로운 클라이언트 접속이 들어올 때마다 4~5과정을 반복한다.

![active](https://user-images.githubusercontent.com/78485996/136697065-8f933cf2-a637-40f0-8de7-75ed96057278.PNG)

### bind()함수

bind()함수는 소켓 지역 IP 주소와 지역 포트번호를 결정한다.

~~~c++
int bind(
    SOCKET s,
    const struct sockaddr *name,
    int namelen
)
~~~

1. s : 클라이언트 접속을 수용할 목적으로 만든 소켓으로, 지역 IP 주소와 지역 포트 번호가 아직 결정되지 않은 상태이다.
2. name : 소켓 주소 구조체(TCP/IP의 경우 SOCKADDR_IN 또는 SOCKADDR_IN6)를 지역 IP 주소와 지역 포트번호로 초기화하여 전달한다.
3. namelen : 소켓 주소 구조체의 길이(바이트 단위)이다.

### listen() 함수

listen() 함수는 소켓의 TCP 포트 상태을 LISTENING으로 바꾼다. 이는 클라이언트 접속을 받아들일 수 있는 상태가 됨을 의미한다.

~~~c++
int listen(
    SOCKET s,
    int backlog
);
~~~

1. s : 클라이언트 접속을 수용할 목적으로 만든 소켓으로, bind()함수로 지역 IP 주소와 지역 포트번호를 설정한 상태다.
2. backlog : 서버가 당장 처리하지 않더라도 접속 가능한 클라이언트의 개수다. 클라이언트의 접속 정보는 연결 큐에 저정되는데, backlog는 이 연결 큐의 길이를 나타낸다. 하부 프로토콜에서 지원 가능한 최대값을 사용하려면 SOMAXCONN값을 대입한다.

### accetp() 함수

accetp() 함수는 접속한 클라이언트와 통신할 수 있도록 새로운 소켓을 생성해서 리턴한다. 또한 접속한 클라이언트의 주소 정보도 알려준다.

~~~c++
SOCKET accept(
    SOCKET s,
    struct sockaddr *addr,
    int *addrlen
)
~~~

1. s : 클라이언트 접속을 수용할 목적으로 만든 소켓으로, bind()함수로 지역 IP주소와 지역 포트번호를 설정하고 listen()함수로 포트상태를 LISTENING으로 변경한 상태다.
2. addr : 소켓 구조 구조체를 전달하면 접속한 클라이언트의 주소 정보로 채워진다.
3. addrlen : 정수형 변수를 addr이 가르키는 소켓 주소 구조체의 크기로 초기화한 후 전달한다. accept함수가 리턴하면 *addrlen변수는 accept()가 채웒은 주소 정보의 크기(바이트 단위)를 가지게 된다.

접속한 클라이언트가 없는 경우 accpet()함수는 서버를 대기 상태로 만든다. 클라이언트가 접속하면 서버는 깨어나고 accepte()함수는 비로소 리턴하게 된다.


## TCP 클라이언트 함수

일반적으로 TCP 클라이언트는 다음과 같은 순서로 함수를 호출한다.

1. socket()함수로 소켓을 생삼함으로써 사용할 프로토콜을 결정한다.
2. connect()함수로 서버에 접속한다. 이때 원격 IP 주소와 원격 포트번호는 물론 지역 IP 주소와 지역 포트 번호도 결정된다.
3. send(), recv()등의 데이터 전송 함수로 서버와 통신한 후, closesocket()함수로 소켓을 닫늗다.

### conect() 함수

conect() 함수는 TCP 프로토콜 수준에서 서버와 논리적인 연결을 설정한다.

~~~c++
int connect(
    SOCKET s,
    const struct sockaddr *name,
    int namelen
);
~~~

1. s : 서버와 통신할 목적으로 만든 소켓이다.
2. name : 소켓 주소 구조체를 서버 주소로 초기화하여 전달한다.
3. namelen : 서버 주소 구조체의 길이다.

일반적으로 클라이언트는 서버와 달리 bind()를 호출하지 않는다. bind()함수를 호출하지 않은 상태에서 connect()함수를 호출하면, 운영체제가 자동으로 지역 IP 주소와 지역 포트번호를 할당해 준다. 

## TCP 데이터 전송 함수

데이터 전송 함수는 크게 데이터를 내보내는 함수와 데이터를 받는 함수로 구분할 수 있다. 가장 기본이 되는 함수는 send()와 recv()며 그 외에 sendto(),recvfrom()과 WSASend*(), WSARecv*()형태의 확장 함수가 존재한다.

송신 버퍼는 데이터를 전송하기 전에 임시로 저장해두는 영역이고 수닛 버퍼는 받은 데이터를 응용프로그램이 처리하기 전까지 임시로 저장해두는 영역이다. 송신버퍼와 수신버퍼를 통틀어 소켓 버퍼라 부른다. send()와 recv()함수는 소켓 버퍼에 접근할 수 있게 만든 함수라 보면 된다.

여기서 다룰 TCP 프로토콜은 응용 프로그램이 보낸 데이터의 경계를 구분하지 않는다는 특징이 있다. 따라서 TCP 서버-클라이언트를 작성할 때는 데이터 경계 구분을 위한 상호 약속이 필요하며 이를 응용프로그램 수준에서 처리해야 한다.

### send()함수

send()함수는 응용 프로그램 데이터를 운영체제의 송신 버퍼에 복사함으로써 데이터를 전송한다. send()함수는 데이터 복사가 성공하면 곧바로 리턴한다. 따라서 send()함수가 리턴했다고 실제 데이터가 전송된 것은 아니며 일정 시간이 지나야만 하부 프로토콜을 통해 전송이 완료된다.

~~~c++
int send(
    SOCKET s,
    const char *buf,
    int len,
    in flags
);
~~~

1. s : 통신할 대상과 연결된(connected) 소켓이다.
2. buf : 보낼 데이터를 담고 있는 응용 프로그램 버퍼의 주소이다.
3. len : 보낼 데이터 크기다.
4. flags : send()함수의 동작을 바꾸는 옵션으로 대부분 0을 사용하면 된다.

send()함수는 첫 번째 인자로 전달하는 소켓으 특성에 따라 다음과 같이 두 종류에 성공적인 리턴을 할 수 있다.

**블로킹(blocking) 소켓** : 지금까지 생성한 소켓은 모두 블로킹 소켓이다. 블로킹 소켓을 대상으로 send()함수를 호출하면 송신 버퍼의 여유공간 없이 send()함수의 세번째 인자인 len보다 작을 경우 해당 프로세스는 대기 상태가 된다. 송신 버퍼에 충분한 공간이 생기면 프로세스는 깨어나고 len 크기만큼의 데이터를 복사가 일어난 후 send()함수가 리턴한다. 이 경우 send()함수의 리턴 값은 len과 같다.

**넌블로킹(nonblocking) 소켓** : ioctlsocket()함수를 이용하면 블로킹 소켓을 넌블로켕 소켓으로 바꿀 수 있다. 넌블로킹 소켓을 대상으로 send()함수를 호출하면 송신 버퍼의 여유공강만큼 데이터를 복사한 후 실제 복사한 바이트 수를 리턴한다. 이 경우 send() 함수의 리턴값은 최소1, 최대 len이 된다.

### recv()함수

recv()함수는 운여ㅑㅇ체제의 수신 버퍼에 도착한 데이터를 응용 프로그램 버퍼에 복사한다.

~~~c++
int recv(
    SOCKET s,
    char *buf,
    int len,
    int flags
);
~~~








